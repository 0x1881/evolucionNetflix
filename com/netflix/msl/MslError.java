// 
// Decompiled by Procyon v0.5.30
// 

package com.netflix.msl;

import java.util.HashSet;
import java.util.Set;

public class MslError
{
    private static final int BASE = 100000;
    public static final MslError CIPHERTEXT_BAD_PADDING;
    public static final MslError CIPHERTEXT_ENVELOPE_ENCODE_ERROR;
    public static final MslError CIPHERTEXT_ENVELOPE_PARSE_ERROR;
    public static final MslError CIPHERTEXT_ILLEGAL_BLOCK_SIZE;
    public static final MslError COMPRESSION_ERROR;
    public static final MslError DECRYPT_ERROR;
    public static final MslError DECRYPT_NOT_SUPPORTED;
    public static final MslError DERIVEKEY_ERROR;
    public static final MslError DIGEST_ERROR;
    public static final MslError EMAILPASSWORD_BLANK;
    public static final MslError EMAILPASSWORD_INCORRECT;
    public static final MslError ENCRYPT_ERROR;
    public static final MslError ENCRYPT_NOT_SUPPORTED;
    public static final MslError ENTITYAUTH_CIPHERTEXT_INVALID;
    public static final MslError ENTITYAUTH_FACTORY_NOT_FOUND;
    public static final MslError ENTITYAUTH_MASTERTOKEN_INVALID;
    public static final MslError ENTITYAUTH_MASTERTOKEN_NOT_DECRYPTED;
    public static final MslError ENTITYAUTH_SIGNATURE_INVALID;
    public static final MslError ENTITYAUTH_VERIFICATION_FAILED;
    public static final MslError ENTITY_NOT_FOUND;
    public static final MslError ENTITY_REJECTED_BY_APP;
    public static final MslError ENTITY_REVOKED;
    public static final MslError ENVELOPE_HASH_MISMATCH;
    public static final MslError ENVELOPE_KEY_ID_MISMATCH;
    public static final MslError GENERATEKEY_ERROR;
    public static final MslError HANDSHAKE_DATA_MISSING;
    public static final MslError HEADER_DATA_INVALID;
    public static final MslError HEADER_DATA_MISSING;
    public static final MslError HEADER_SIGNATURE_INVALID;
    public static final MslError HMAC_ERROR;
    public static final MslError INCOMPLETE_NONREPLAYABLE_MESSAGE;
    public static final MslError INCORRECT_ENTITYAUTH_DATA;
    public static final MslError INSUFFICIENT_CIPHERTEXT;
    public static final MslError INTERNAL_CODE_NEGATIVE;
    public static final MslError INTERNAL_EXCEPTION;
    public static final MslError INVALID_ALGORITHM_PARAMS;
    public static final MslError INVALID_CIPHERTEXT;
    public static final MslError INVALID_ENCRYPTION_KEY;
    public static final MslError INVALID_HMAC_KEY;
    public static final MslError INVALID_IV;
    public static final MslError INVALID_JWK;
    public static final MslError INVALID_JWK_KEYDATA;
    public static final MslError INVALID_PRIVATE_KEY;
    public static final MslError INVALID_PUBLIC_KEY;
    public static final MslError INVALID_SIGNATURE;
    public static final MslError INVALID_SYMMETRIC_KEY;
    public static final MslError INVALID_WRAPPING_KEY;
    public static final MslError INVALID_WRAP_CIPHERTEXT;
    public static final MslError JSON_ENCODE_ERROR;
    public static final MslError JSON_PARSE_ERROR;
    public static final MslError JWE_ALGORITHM_MISMATCH;
    public static final MslError JWE_ENCODE_ERROR;
    public static final MslError JWE_PARSE_ERROR;
    public static final MslError KEYX_DERIVATION_KEY_MISSING;
    public static final MslError KEYX_FACTORY_NOT_FOUND;
    public static final MslError KEYX_INCORRECT_DATA;
    public static final MslError KEYX_INCORRECT_MECHANISM;
    public static final MslError KEYX_INVALID_ENCRYPTION_KEY;
    public static final MslError KEYX_INVALID_HMAC_KEY;
    public static final MslError KEYX_INVALID_PUBLIC_KEY;
    public static final MslError KEYX_INVALID_WRAPDATA;
    public static final MslError KEYX_INVALID_WRAPPING_KEY;
    public static final MslError KEYX_MASTER_TOKEN_MISSING;
    public static final MslError KEYX_PRIVATE_KEY_MISSING;
    public static final MslError KEYX_PUBLIC_KEY_MISSING;
    public static final MslError KEYX_REQUEST_NOT_FOUND;
    public static final MslError KEYX_RESPONSE_REQUEST_MISMATCH;
    public static final MslError KEYX_WRAPPING_KEY_ID_MISSING;
    public static final MslError KEYX_WRAPPING_KEY_MISSING;
    public static final MslError KEY_EXPORT_ERROR;
    public static final MslError KEY_IMPORT_ERROR;
    public static final MslError MASTERTOKEN_EXPIRES_BEFORE_RENEWAL;
    public static final MslError MASTERTOKEN_IDENTITY_REVOKED;
    public static final MslError MASTERTOKEN_KEY_CREATION_ERROR;
    public static final MslError MASTERTOKEN_REJECTED_BY_APP;
    public static final MslError MASTERTOKEN_SEQUENCE_NUMBER_OUT_OF_RANGE;
    public static final MslError MASTERTOKEN_SEQUENCE_NUMBER_OUT_OF_SYNC;
    public static final MslError MASTERTOKEN_SERIAL_NUMBER_OUT_OF_RANGE;
    public static final MslError MASTERTOKEN_SESSIONDATA_INVALID;
    public static final MslError MASTERTOKEN_SESSIONDATA_MISSING;
    public static final MslError MASTERTOKEN_SESSIONDATA_PARSE_ERROR;
    public static final MslError MASTERTOKEN_SIGNATURE_INVALID;
    public static final MslError MASTERTOKEN_TOKENDATA_INVALID;
    public static final MslError MASTERTOKEN_TOKENDATA_MISSING;
    public static final MslError MASTERTOKEN_TOKENDATA_PARSE_ERROR;
    public static final MslError MASTERTOKEN_UNTRUSTED;
    public static final MslError MESSAGE_DATA_MISSING;
    public static final MslError MESSAGE_ENTITYDATABASED_VERIFICATION_FAILED;
    public static final MslError MESSAGE_ENTITY_NOT_FOUND;
    public static final MslError MESSAGE_EXPIRED;
    public static final MslError MESSAGE_FORMAT_ERROR;
    public static final MslError MESSAGE_ID_OUT_OF_RANGE;
    public static final MslError MESSAGE_MASTERTOKENBASED_VERIFICATION_FAILED;
    public static final MslError MESSAGE_PEER_SERVICETOKEN_MISMATCH;
    public static final MslError MESSAGE_RECIPIENT_MISMATCH;
    public static final MslError MESSAGE_REPLAYED;
    public static final MslError MESSAGE_REPLAYED_UNRECOVERABLE;
    public static final MslError MESSAGE_SERVICETOKEN_MISMATCH;
    public static final MslError MESSAGE_VERIFICATION_FAILED;
    public static final MslError MSL_COMMS_FAILURE;
    public static final MslError NONE;
    public static final MslError NONREPLAYABLE_ID_OUT_OF_RANGE;
    public static final MslError NONREPLAYABLE_MESSAGE_REQUIRES_MASTERTOKEN;
    public static final MslError PAYLOAD_DATA_CORRUPT;
    public static final MslError PAYLOAD_DATA_MISSING;
    public static final MslError PAYLOAD_INVALID;
    public static final MslError PAYLOAD_MESSAGE_ID_MISMATCH;
    public static final MslError PAYLOAD_MESSAGE_ID_OUT_OF_RANGE;
    public static final MslError PAYLOAD_SEQUENCE_NUMBER_MISMATCH;
    public static final MslError PAYLOAD_SEQUENCE_NUMBER_OUT_OF_RANGE;
    public static final MslError PAYLOAD_SIGNATURE_INVALID;
    public static final MslError PAYLOAD_VERIFICATION_FAILED;
    public static final MslError PLAINTEXT_BAD_PADDING;
    public static final MslError PLAINTEXT_ILLEGAL_BLOCK_SIZE;
    public static final MslError REQUEST_REQUIRES_USERAUTHDATA;
    public static final MslError RESERVED_2012;
    public static final MslError RESPONSE_REQUIRES_ENCRYPTION;
    public static final MslError RESPONSE_REQUIRES_INTEGRITY_PROTECTION;
    public static final MslError RESPONSE_REQUIRES_MASTERTOKEN;
    public static final MslError RESPONSE_REQUIRES_USERIDTOKEN;
    public static final MslError RSA_PRIVATEKEY_NOT_FOUND;
    public static final MslError RSA_PUBLICKEY_NOT_FOUND;
    public static final MslError SERVICETOKEN_MASTERTOKEN_MISMATCH;
    public static final MslError SERVICETOKEN_MASTERTOKEN_NOT_FOUND;
    public static final MslError SERVICETOKEN_MASTERTOKEN_SERIAL_NUMBER_OUT_OF_RANGE;
    public static final MslError SERVICETOKEN_SERVICEDATA_INVALID;
    public static final MslError SERVICETOKEN_SIGNATURE_INVALID;
    public static final MslError SERVICETOKEN_TOKENDATA_INVALID;
    public static final MslError SERVICETOKEN_TOKENDATA_MISSING;
    public static final MslError SERVICETOKEN_USERIDTOKEN_MISMATCH;
    public static final MslError SERVICETOKEN_USERIDTOKEN_NOT_FOUND;
    public static final MslError SERVICETOKEN_USERIDTOKEN_SERIAL_NUMBER_OUT_OF_RANGE;
    public static final MslError SESSION_KEY_CREATION_FAILURE;
    public static final MslError SIGNATURE_ENVELOPE_ENCODE_ERROR;
    public static final MslError SIGNATURE_ENVELOPE_PARSE_ERROR;
    public static final MslError SIGNATURE_ERROR;
    public static final MslError SIGN_NOT_SUPPORTED;
    public static final MslError UNCOMPRESSION_ERROR;
    public static final MslError UNEXPECTED_MESSAGE_SENDER;
    public static final MslError UNEXPECTED_RESPONSE_MESSAGE_ID;
    public static final MslError UNIDENTIFIED_ALGORITHM;
    public static final MslError UNIDENTIFIED_CIPHERSPEC;
    public static final MslError UNIDENTIFIED_CIPHERTEXT_ENVELOPE;
    public static final MslError UNIDENTIFIED_COMPRESSION;
    public static final MslError UNIDENTIFIED_ENTITYAUTH_SCHEME;
    public static final MslError UNIDENTIFIED_JWK_ALGORITHM;
    public static final MslError UNIDENTIFIED_JWK_KEYOP;
    public static final MslError UNIDENTIFIED_JWK_TYPE;
    public static final MslError UNIDENTIFIED_JWK_USAGE;
    public static final MslError UNIDENTIFIED_KEYX_KEY_ID;
    public static final MslError UNIDENTIFIED_KEYX_MECHANISM;
    public static final MslError UNIDENTIFIED_KEYX_SCHEME;
    public static final MslError UNIDENTIFIED_SIGNATURE_ENVELOPE;
    public static final MslError UNIDENTIFIED_USERAUTH_MECHANISM;
    public static final MslError UNIDENTIFIED_USERAUTH_SCHEME;
    public static final MslError UNKNOWN_KEYX_PARAMETERS_ID;
    public static final MslError UNSUPPORTED_CIPHERTEXT_ENVELOPE;
    public static final MslError UNSUPPORTED_COMPRESSION;
    public static final MslError UNSUPPORTED_ENTITYAUTH_DATA;
    public static final MslError UNSUPPORTED_JWE_ALGORITHM;
    public static final MslError UNSUPPORTED_JWE_SERIALIZATION;
    public static final MslError UNSUPPORTED_JWK_ALGORITHM;
    public static final MslError UNSUPPORTED_KEY;
    public static final MslError UNSUPPORTED_KEYX_KEY_ID;
    public static final MslError UNSUPPORTED_KEYX_MECHANISM;
    public static final MslError UNSUPPORTED_KEYX_SCHEME;
    public static final MslError UNSUPPORTED_SIGNATURE_ENVELOPE;
    public static final MslError UNSUPPORTED_USERAUTH_DATA;
    public static final MslError UNSUPPORTED_USERAUTH_MECHANISM;
    public static final MslError UNWRAP_ERROR;
    public static final MslError UNWRAP_NOT_SUPPORTED;
    public static final MslError USERAUTH_ENTITYUSER_INCORRECT_DATA;
    public static final MslError USERAUTH_ENTITY_INCORRECT_DATA;
    public static final MslError USERAUTH_ENTITY_MISMATCH;
    public static final MslError USERAUTH_FACTORY_NOT_FOUND;
    public static final MslError USERAUTH_MASTERTOKEN_INVALID;
    public static final MslError USERAUTH_MASTERTOKEN_MISSING;
    public static final MslError USERAUTH_MASTERTOKEN_NOT_DECRYPTED;
    public static final MslError USERAUTH_USERIDTOKEN_INVALID;
    public static final MslError USERAUTH_USERIDTOKEN_MISSING;
    public static final MslError USERAUTH_USERIDTOKEN_NOT_DECRYPTED;
    public static final MslError USERIDTOKEN_EXPIRES_BEFORE_RENEWAL;
    public static final MslError USERIDTOKEN_IDENTITY_INVALID;
    public static final MslError USERIDTOKEN_IDENTITY_NOT_ASSOCIATED_WITH_ENTITY;
    public static final MslError USERIDTOKEN_MASTERTOKEN_MISMATCH;
    public static final MslError USERIDTOKEN_MASTERTOKEN_NOT_FOUND;
    public static final MslError USERIDTOKEN_MASTERTOKEN_NULL;
    public static final MslError USERIDTOKEN_MASTERTOKEN_SERIAL_NUMBER_OUT_OF_RANGE;
    public static final MslError USERIDTOKEN_NOT_DECRYPTED;
    public static final MslError USERIDTOKEN_REJECTED_BY_APP;
    public static final MslError USERIDTOKEN_REVOKED;
    public static final MslError USERIDTOKEN_SERIAL_NUMBER_OUT_OF_RANGE;
    public static final MslError USERIDTOKEN_SIGNATURE_INVALID;
    public static final MslError USERIDTOKEN_TOKENDATA_INVALID;
    public static final MslError USERIDTOKEN_TOKENDATA_MISSING;
    public static final MslError USERIDTOKEN_TOKENDATA_PARSE_ERROR;
    public static final MslError USERIDTOKEN_USERAUTH_DATA_MISMATCH;
    public static final MslError USERIDTOKEN_USERDATA_INVALID;
    public static final MslError USERIDTOKEN_USERDATA_MISSING;
    public static final MslError USERIDTOKEN_USERDATA_PARSE_ERROR;
    public static final MslError USER_REJECTED_BY_APP;
    public static final MslError VERIFY_NOT_SUPPORTED;
    public static final MslError WRAP_ERROR;
    public static final MslError WRAP_KEY_CREATION_FAILURE;
    public static final MslError WRAP_NOT_SUPPORTED;
    public static final MslError X509CERT_ENCODE_ERROR;
    public static final MslError X509CERT_EXPIRED;
    public static final MslError X509CERT_INVALID;
    public static final MslError X509CERT_NOT_YET_VALID;
    public static final MslError X509CERT_PARSE_ERROR;
    public static final MslError X509CERT_VERIFICATION_FAILED;
    private static final Set<Integer> internalCodes;
    private final int internalCode;
    private final String msg;
    private final MslConstants$ResponseCode responseCode;
    
    static {
        internalCodes = new HashSet<Integer>();
        JSON_PARSE_ERROR = new MslError(0, MslConstants$ResponseCode.FAIL, "Error parsing JSON.");
        JSON_ENCODE_ERROR = new MslError(1, MslConstants$ResponseCode.FAIL, "Error encoding JSON.");
        ENVELOPE_HASH_MISMATCH = new MslError(2, MslConstants$ResponseCode.FAIL, "Computed hash does not match envelope hash.");
        INVALID_PUBLIC_KEY = new MslError(3, MslConstants$ResponseCode.FAIL, "Invalid public key provided.");
        INVALID_PRIVATE_KEY = new MslError(4, MslConstants$ResponseCode.FAIL, "Invalid private key provided.");
        PLAINTEXT_ILLEGAL_BLOCK_SIZE = new MslError(5, MslConstants$ResponseCode.FAIL, "Plaintext is not a multiple of the block size.");
        PLAINTEXT_BAD_PADDING = new MslError(6, MslConstants$ResponseCode.FAIL, "Plaintext contains incorrect padding.");
        CIPHERTEXT_ILLEGAL_BLOCK_SIZE = new MslError(7, MslConstants$ResponseCode.FAIL, "Ciphertext is not a multiple of the block size.");
        CIPHERTEXT_BAD_PADDING = new MslError(8, MslConstants$ResponseCode.FAIL, "Ciphertext contains incorrect padding.");
        ENCRYPT_NOT_SUPPORTED = new MslError(9, MslConstants$ResponseCode.FAIL, "Encryption not supported.");
        DECRYPT_NOT_SUPPORTED = new MslError(10, MslConstants$ResponseCode.FAIL, "Decryption not supported.");
        ENVELOPE_KEY_ID_MISMATCH = new MslError(11, MslConstants$ResponseCode.FAIL, "Encryption envelope key ID does not match crypto context key ID.");
        CIPHERTEXT_ENVELOPE_PARSE_ERROR = new MslError(12, MslConstants$ResponseCode.FAIL, "Error parsing ciphertext envelope.");
        CIPHERTEXT_ENVELOPE_ENCODE_ERROR = new MslError(13, MslConstants$ResponseCode.FAIL, "Error encoding ciphertext envelope.");
        SIGN_NOT_SUPPORTED = new MslError(14, MslConstants$ResponseCode.FAIL, "Sign not supported.");
        VERIFY_NOT_SUPPORTED = new MslError(15, MslConstants$ResponseCode.FAIL, "Verify not suppoprted.");
        SIGNATURE_ERROR = new MslError(16, MslConstants$ResponseCode.FAIL, "Signature not initialized or unable to process data/signature.");
        HMAC_ERROR = new MslError(17, MslConstants$ResponseCode.FAIL, "Error computing HMAC.");
        ENCRYPT_ERROR = new MslError(18, MslConstants$ResponseCode.FAIL, "Error encrypting plaintext.");
        DECRYPT_ERROR = new MslError(19, MslConstants$ResponseCode.FAIL, "Error decrypting ciphertext.");
        INSUFFICIENT_CIPHERTEXT = new MslError(20, MslConstants$ResponseCode.FAIL, "Insufficient ciphertext for decryption.");
        SESSION_KEY_CREATION_FAILURE = new MslError(21, MslConstants$ResponseCode.FAIL, "Error when creating session keys.");
        INVALID_SYMMETRIC_KEY = new MslError(24, MslConstants$ResponseCode.FAIL, "Invalid symmetric key.");
        INVALID_ENCRYPTION_KEY = new MslError(25, MslConstants$ResponseCode.FAIL, "Invalid encryption key.");
        INVALID_HMAC_KEY = new MslError(26, MslConstants$ResponseCode.FAIL, "Invalid HMAC key.");
        WRAP_NOT_SUPPORTED = new MslError(27, MslConstants$ResponseCode.FAIL, "Wrap not supported.");
        UNWRAP_NOT_SUPPORTED = new MslError(28, MslConstants$ResponseCode.FAIL, "Unwrap not supported.");
        UNIDENTIFIED_JWK_TYPE = new MslError(29, MslConstants$ResponseCode.FAIL, "Unidentified JSON web key type.");
        UNIDENTIFIED_JWK_USAGE = new MslError(30, MslConstants$ResponseCode.FAIL, "Unidentified JSON web key usage.");
        UNIDENTIFIED_JWK_ALGORITHM = new MslError(31, MslConstants$ResponseCode.FAIL, "Unidentified JSON web key algorithm.");
        WRAP_ERROR = new MslError(32, MslConstants$ResponseCode.FAIL, "Error wrapping plaintext.");
        UNWRAP_ERROR = new MslError(33, MslConstants$ResponseCode.FAIL, "Error unwrapping ciphertext.");
        INVALID_JWK = new MslError(34, MslConstants$ResponseCode.FAIL, "Invalid JSON web key.");
        INVALID_JWK_KEYDATA = new MslError(35, MslConstants$ResponseCode.FAIL, "Invalid JSON web key keydata.");
        UNSUPPORTED_JWK_ALGORITHM = new MslError(36, MslConstants$ResponseCode.FAIL, "Unsupported JSON web key algorithm.");
        WRAP_KEY_CREATION_FAILURE = new MslError(37, MslConstants$ResponseCode.FAIL, "Error when creating wrapping key.");
        INVALID_WRAP_CIPHERTEXT = new MslError(38, MslConstants$ResponseCode.FAIL, "Invalid wrap ciphertext.");
        UNSUPPORTED_JWE_ALGORITHM = new MslError(39, MslConstants$ResponseCode.FAIL, "Unsupported JSON web encryption algorithm.");
        JWE_ENCODE_ERROR = new MslError(40, MslConstants$ResponseCode.FAIL, "Error encoding JSON web encryption header.");
        JWE_PARSE_ERROR = new MslError(41, MslConstants$ResponseCode.FAIL, "Error parsing JSON web encryption header.");
        INVALID_ALGORITHM_PARAMS = new MslError(42, MslConstants$ResponseCode.FAIL, "Invalid algorithm parameters.");
        JWE_ALGORITHM_MISMATCH = new MslError(43, MslConstants$ResponseCode.FAIL, "JSON web encryption header algorithms mismatch.");
        KEY_IMPORT_ERROR = new MslError(44, MslConstants$ResponseCode.FAIL, "Error importing key.");
        KEY_EXPORT_ERROR = new MslError(45, MslConstants$ResponseCode.FAIL, "Error exporting key.");
        DIGEST_ERROR = new MslError(46, MslConstants$ResponseCode.FAIL, "Error in digest.");
        UNSUPPORTED_KEY = new MslError(47, MslConstants$ResponseCode.FAIL, "Unsupported key type or algorithm.");
        UNSUPPORTED_JWE_SERIALIZATION = new MslError(48, MslConstants$ResponseCode.FAIL, "Unsupported JSON web encryption serialization.");
        INVALID_WRAPPING_KEY = new MslError(51, MslConstants$ResponseCode.FAIL, "Invalid wrapping key.");
        UNIDENTIFIED_CIPHERTEXT_ENVELOPE = new MslError(52, MslConstants$ResponseCode.FAIL, "Unidentified ciphertext envelope version.");
        UNIDENTIFIED_SIGNATURE_ENVELOPE = new MslError(53, MslConstants$ResponseCode.FAIL, "Unidentified signature envelope version.");
        UNSUPPORTED_CIPHERTEXT_ENVELOPE = new MslError(54, MslConstants$ResponseCode.FAIL, "Unsupported ciphertext envelope version.");
        UNSUPPORTED_SIGNATURE_ENVELOPE = new MslError(55, MslConstants$ResponseCode.FAIL, "Unsupported signature envelope version.");
        UNIDENTIFIED_CIPHERSPEC = new MslError(56, MslConstants$ResponseCode.FAIL, "Unidentified cipher specification.");
        UNIDENTIFIED_ALGORITHM = new MslError(57, MslConstants$ResponseCode.FAIL, "Unidentified algorithm.");
        SIGNATURE_ENVELOPE_PARSE_ERROR = new MslError(58, MslConstants$ResponseCode.FAIL, "Error parsing signature envelope.");
        SIGNATURE_ENVELOPE_ENCODE_ERROR = new MslError(59, MslConstants$ResponseCode.FAIL, "Error encoding signature envelope.");
        INVALID_SIGNATURE = new MslError(60, MslConstants$ResponseCode.FAIL, "Invalid signature.");
        DERIVEKEY_ERROR = new MslError(61, MslConstants$ResponseCode.FAIL, "Error deriving key.");
        UNIDENTIFIED_JWK_KEYOP = new MslError(62, MslConstants$ResponseCode.FAIL, "Unidentified JSON web key key operation.");
        GENERATEKEY_ERROR = new MslError(63, MslConstants$ResponseCode.FAIL, "Error generating key.");
        INVALID_IV = new MslError(64, MslConstants$ResponseCode.FAIL, "Invalid initialization vector.");
        INVALID_CIPHERTEXT = new MslError(65, MslConstants$ResponseCode.FAIL, "Invalid ciphertext.");
        MASTERTOKEN_UNTRUSTED = new MslError(1000, MslConstants$ResponseCode.ENTITY_REAUTH, "Master token is not trusted.");
        MASTERTOKEN_KEY_CREATION_ERROR = new MslError(1001, MslConstants$ResponseCode.ENTITY_REAUTH, "Unable to construct symmetric keys from master token.");
        MASTERTOKEN_EXPIRES_BEFORE_RENEWAL = new MslError(1002, MslConstants$ResponseCode.ENTITY_REAUTH, "Master token expiration timestamp is before the renewal window opens.");
        MASTERTOKEN_SESSIONDATA_MISSING = new MslError(1003, MslConstants$ResponseCode.ENTITY_REAUTH, "No master token session data found.");
        MASTERTOKEN_SEQUENCE_NUMBER_OUT_OF_RANGE = new MslError(1004, MslConstants$ResponseCode.ENTITY_REAUTH, "Master token sequence number is out of range.");
        MASTERTOKEN_SERIAL_NUMBER_OUT_OF_RANGE = new MslError(1005, MslConstants$ResponseCode.ENTITY_REAUTH, "Master token serial number is out of range.");
        MASTERTOKEN_TOKENDATA_INVALID = new MslError(1006, MslConstants$ResponseCode.ENTITY_REAUTH, "Invalid master token data.");
        MASTERTOKEN_SIGNATURE_INVALID = new MslError(1007, MslConstants$ResponseCode.ENTITY_REAUTH, "Invalid master token signature.");
        MASTERTOKEN_SESSIONDATA_INVALID = new MslError(1008, MslConstants$ResponseCode.ENTITY_REAUTH, "Invalid master token session data.");
        MASTERTOKEN_SEQUENCE_NUMBER_OUT_OF_SYNC = new MslError(1009, MslConstants$ResponseCode.ENTITY_REAUTH, "Master token sequence number does not have the expected value.");
        MASTERTOKEN_TOKENDATA_MISSING = new MslError(1010, MslConstants$ResponseCode.ENTITY_REAUTH, "No master token data found.");
        MASTERTOKEN_TOKENDATA_PARSE_ERROR = new MslError(1011, MslConstants$ResponseCode.ENTITY_REAUTH, "Error parsing master token data.");
        MASTERTOKEN_SESSIONDATA_PARSE_ERROR = new MslError(1012, MslConstants$ResponseCode.ENTITY_REAUTH, "Error parsing master token session data.");
        MASTERTOKEN_IDENTITY_REVOKED = new MslError(1013, MslConstants$ResponseCode.ENTITY_REAUTH, "Master token entity identity is revoked.");
        MASTERTOKEN_REJECTED_BY_APP = new MslError(1014, MslConstants$ResponseCode.ENTITY_REAUTH, "Master token is rejected by the application.");
        USERIDTOKEN_MASTERTOKEN_MISMATCH = new MslError(2000, MslConstants$ResponseCode.USER_REAUTH, "User ID token master token serial number does not match master token serial number.");
        USERIDTOKEN_NOT_DECRYPTED = new MslError(2001, MslConstants$ResponseCode.USER_REAUTH, "User ID token is not decrypted or verified.");
        USERIDTOKEN_MASTERTOKEN_NULL = new MslError(2002, MslConstants$ResponseCode.USER_REAUTH, "User ID token requires a master token.");
        USERIDTOKEN_EXPIRES_BEFORE_RENEWAL = new MslError(2003, MslConstants$ResponseCode.USER_REAUTH, "User ID token expiration timestamp is before the renewal window opens.");
        USERIDTOKEN_USERDATA_MISSING = new MslError(2004, MslConstants$ResponseCode.USER_REAUTH, "No user ID token user data found.");
        USERIDTOKEN_MASTERTOKEN_NOT_FOUND = new MslError(2005, MslConstants$ResponseCode.USER_REAUTH, "User ID token is bound to an unknown master token.");
        USERIDTOKEN_MASTERTOKEN_SERIAL_NUMBER_OUT_OF_RANGE = new MslError(2006, MslConstants$ResponseCode.USER_REAUTH, "User ID token master token serial number is out of range.");
        USERIDTOKEN_SERIAL_NUMBER_OUT_OF_RANGE = new MslError(2007, MslConstants$ResponseCode.USER_REAUTH, "User ID token serial number is out of range.");
        USERIDTOKEN_TOKENDATA_INVALID = new MslError(2008, MslConstants$ResponseCode.USER_REAUTH, "Invalid user ID token data.");
        USERIDTOKEN_SIGNATURE_INVALID = new MslError(2009, MslConstants$ResponseCode.USER_REAUTH, "Invalid user ID token signature.");
        USERIDTOKEN_USERDATA_INVALID = new MslError(2010, MslConstants$ResponseCode.USER_REAUTH, "Invalid user ID token user data.");
        USERIDTOKEN_IDENTITY_INVALID = new MslError(2011, MslConstants$ResponseCode.USER_REAUTH, "Invalid user ID token user identity.");
        RESERVED_2012 = new MslError(2012, MslConstants$ResponseCode.USER_REAUTH, "The entity is not associated with the user.");
        USERIDTOKEN_USERAUTH_DATA_MISMATCH = new MslError(2015, MslConstants$ResponseCode.USER_REAUTH, "The user ID token and user authentication data user identities do not match.");
        USERIDTOKEN_TOKENDATA_MISSING = new MslError(2016, MslConstants$ResponseCode.USER_REAUTH, "No user ID token data found.");
        USERIDTOKEN_TOKENDATA_PARSE_ERROR = new MslError(2017, MslConstants$ResponseCode.USER_REAUTH, "Error parsing user ID token data.");
        USERIDTOKEN_USERDATA_PARSE_ERROR = new MslError(2018, MslConstants$ResponseCode.USER_REAUTH, "Error parsing user ID token user data.");
        USERIDTOKEN_REVOKED = new MslError(2019, MslConstants$ResponseCode.USER_REAUTH, "User ID token is revoked.");
        USERIDTOKEN_REJECTED_BY_APP = new MslError(2020, MslConstants$ResponseCode.USERDATA_REAUTH, "User ID token is rejected by the application.");
        SERVICETOKEN_MASTERTOKEN_MISMATCH = new MslError(3000, MslConstants$ResponseCode.FAIL, "Service token master token serial number does not match master token serial number.");
        SERVICETOKEN_USERIDTOKEN_MISMATCH = new MslError(3001, MslConstants$ResponseCode.FAIL, "Service token user ID token serial number does not match user ID token serial number.");
        SERVICETOKEN_SERVICEDATA_INVALID = new MslError(3002, MslConstants$ResponseCode.FAIL, "Service token data invalid.");
        SERVICETOKEN_MASTERTOKEN_NOT_FOUND = new MslError(3003, MslConstants$ResponseCode.FAIL, "Service token is bound to an unknown master token.");
        SERVICETOKEN_USERIDTOKEN_NOT_FOUND = new MslError(3004, MslConstants$ResponseCode.FAIL, "Service token is bound to an unknown user ID token.");
        SERVICETOKEN_MASTERTOKEN_SERIAL_NUMBER_OUT_OF_RANGE = new MslError(3005, MslConstants$ResponseCode.FAIL, "Service token master token serial number is out of range.");
        SERVICETOKEN_USERIDTOKEN_SERIAL_NUMBER_OUT_OF_RANGE = new MslError(3006, MslConstants$ResponseCode.FAIL, "Service token user ID token serial number is out of range.");
        SERVICETOKEN_TOKENDATA_INVALID = new MslError(3007, MslConstants$ResponseCode.FAIL, "Invalid service token data.");
        SERVICETOKEN_SIGNATURE_INVALID = new MslError(3008, MslConstants$ResponseCode.FAIL, "Invalid service token signature.");
        SERVICETOKEN_TOKENDATA_MISSING = new MslError(3009, MslConstants$ResponseCode.FAIL, "No service token data found.");
        UNIDENTIFIED_ENTITYAUTH_SCHEME = new MslError(4000, MslConstants$ResponseCode.FAIL, "Unable to identify entity authentication scheme.");
        ENTITYAUTH_FACTORY_NOT_FOUND = new MslError(4001, MslConstants$ResponseCode.FAIL, "No factory registered for entity authentication scheme.");
        X509CERT_PARSE_ERROR = new MslError(4002, MslConstants$ResponseCode.ENTITYDATA_REAUTH, "Error parsing X.509 certificate data.");
        X509CERT_ENCODE_ERROR = new MslError(4003, MslConstants$ResponseCode.ENTITYDATA_REAUTH, "Error encoding X.509 certificate data.");
        X509CERT_VERIFICATION_FAILED = new MslError(4004, MslConstants$ResponseCode.ENTITYDATA_REAUTH, "X.509 certificate verification failed.");
        ENTITY_NOT_FOUND = new MslError(4005, MslConstants$ResponseCode.FAIL, "Entity not recognized.");
        INCORRECT_ENTITYAUTH_DATA = new MslError(4006, MslConstants$ResponseCode.FAIL, "Entity used incorrect entity authentication data type.");
        RSA_PUBLICKEY_NOT_FOUND = new MslError(4007, MslConstants$ResponseCode.ENTITYDATA_REAUTH, "RSA public key not found.");
        UNSUPPORTED_ENTITYAUTH_DATA = new MslError(4023, MslConstants$ResponseCode.FAIL, "Unsupported entity authentication data.");
        ENTITY_REVOKED = new MslError(4025, MslConstants$ResponseCode.FAIL, "Entity is revoked.");
        ENTITY_REJECTED_BY_APP = new MslError(4026, MslConstants$ResponseCode.ENTITYDATA_REAUTH, "Entity is rejected by the application.");
        X509CERT_EXPIRED = new MslError(4028, MslConstants$ResponseCode.ENTITYDATA_REAUTH, "X.509 certificate is expired.");
        X509CERT_NOT_YET_VALID = new MslError(4029, MslConstants$ResponseCode.ENTITYDATA_REAUTH, "X.509 certificate is not yet valid.");
        X509CERT_INVALID = new MslError(4030, MslConstants$ResponseCode.ENTITYDATA_REAUTH, "X.509 certificate is invalid.");
        RSA_PRIVATEKEY_NOT_FOUND = new MslError(4031, MslConstants$ResponseCode.ENTITYDATA_REAUTH, "RSA private key not found.");
        ENTITYAUTH_MASTERTOKEN_NOT_DECRYPTED = new MslError(4032, MslConstants$ResponseCode.FAIL, "Entity authentication data master token is not decrypted or verified.");
        ENTITYAUTH_SIGNATURE_INVALID = new MslError(4033, MslConstants$ResponseCode.ENTITYDATA_REAUTH, "Invalid entity authentication data siganture.");
        ENTITYAUTH_CIPHERTEXT_INVALID = new MslError(4034, MslConstants$ResponseCode.ENTITYDATA_REAUTH, "Invalid entity authentication data ciphertext.");
        ENTITYAUTH_VERIFICATION_FAILED = new MslError(4035, MslConstants$ResponseCode.ENTITYDATA_REAUTH, "Entity authentication data signature verification failed.");
        ENTITYAUTH_MASTERTOKEN_INVALID = new MslError(4036, MslConstants$ResponseCode.FAIL, "Invalid entity authentication data master token.");
        UNIDENTIFIED_USERAUTH_SCHEME = new MslError(5003, MslConstants$ResponseCode.FAIL, "Unable to identify user authentication scheme.");
        USERAUTH_FACTORY_NOT_FOUND = new MslError(5004, MslConstants$ResponseCode.FAIL, "No factory registered for user authentication scheme.");
        EMAILPASSWORD_BLANK = new MslError(5005, MslConstants$ResponseCode.USERDATA_REAUTH, "Email or password is blank.");
        EMAILPASSWORD_INCORRECT = new MslError(5007, MslConstants$ResponseCode.USERDATA_REAUTH, "Email or password is incorrect.");
        UNSUPPORTED_USERAUTH_DATA = new MslError(5008, MslConstants$ResponseCode.FAIL, "Unsupported user authentication data.");
        USERAUTH_USERIDTOKEN_INVALID = new MslError(5011, MslConstants$ResponseCode.USERDATA_REAUTH, "User authentication data user ID token is invalid.");
        UNIDENTIFIED_USERAUTH_MECHANISM = new MslError(5013, MslConstants$ResponseCode.FAIL, "Unable to identify user authentication mechanism.");
        UNSUPPORTED_USERAUTH_MECHANISM = new MslError(5014, MslConstants$ResponseCode.FAIL, "Unsupported user authentication mechanism.");
        USERAUTH_MASTERTOKEN_MISSING = new MslError(5016, MslConstants$ResponseCode.USERDATA_REAUTH, "User authentication required master token is missing.");
        USERAUTH_USERIDTOKEN_NOT_DECRYPTED = new MslError(5021, MslConstants$ResponseCode.USERDATA_REAUTH, "User authentication data user ID token is not decrypted or verified.");
        USERAUTH_MASTERTOKEN_INVALID = new MslError(5024, MslConstants$ResponseCode.USERDATA_REAUTH, "User authentication data master token is invalid.");
        USERAUTH_MASTERTOKEN_NOT_DECRYPTED = new MslError(5025, MslConstants$ResponseCode.USERDATA_REAUTH, "User authentication data master token is not decrypted or verified.");
        USERAUTH_USERIDTOKEN_MISSING = new MslError(5030, MslConstants$ResponseCode.USERDATA_REAUTH, "User authentication required user ID token is missing.");
        USERAUTH_ENTITY_MISMATCH = new MslError(5032, MslConstants$ResponseCode.USERDATA_REAUTH, "User authentication data does not match entity identity.");
        USERAUTH_ENTITY_INCORRECT_DATA = new MslError(5033, MslConstants$ResponseCode.FAIL, "Entity used incorrect user authentication data type.");
        USER_REJECTED_BY_APP = new MslError(5037, MslConstants$ResponseCode.USERDATA_REAUTH, "User is rejected by the application.");
        USERIDTOKEN_IDENTITY_NOT_ASSOCIATED_WITH_ENTITY = new MslError(5040, MslConstants$ResponseCode.USERDATA_REAUTH, "The entity is not associated with the user.");
        USERAUTH_ENTITYUSER_INCORRECT_DATA = new MslError(5041, MslConstants$ResponseCode.USERDATA_REAUTH, "Entity and user combination used incorrect user authentication data type.");
        UNSUPPORTED_COMPRESSION = new MslError(6000, MslConstants$ResponseCode.FAIL, "Unsupported compression algorithm.");
        COMPRESSION_ERROR = new MslError(6001, MslConstants$ResponseCode.FAIL, "Error compressing data.");
        UNCOMPRESSION_ERROR = new MslError(6002, MslConstants$ResponseCode.FAIL, "Error uncompressing data.");
        MESSAGE_ENTITY_NOT_FOUND = new MslError(6003, MslConstants$ResponseCode.FAIL, "Message header entity authentication data or master token not found.");
        PAYLOAD_MESSAGE_ID_MISMATCH = new MslError(6004, MslConstants$ResponseCode.FAIL, "Payload chunk message ID does not match header message ID .");
        PAYLOAD_SEQUENCE_NUMBER_MISMATCH = new MslError(6005, MslConstants$ResponseCode.FAIL, "Payload chunk sequence number does not match expected sequence number.");
        PAYLOAD_VERIFICATION_FAILED = new MslError(6006, MslConstants$ResponseCode.FAIL, "Payload chunk payload signature verification failed.");
        MESSAGE_DATA_MISSING = new MslError(6007, MslConstants$ResponseCode.FAIL, "No message data found.");
        MESSAGE_FORMAT_ERROR = new MslError(6008, MslConstants$ResponseCode.FAIL, "Malformed message data.");
        MESSAGE_VERIFICATION_FAILED = new MslError(6009, MslConstants$ResponseCode.FAIL, "Message header/error data signature verification failed.");
        HEADER_DATA_MISSING = new MslError(6010, MslConstants$ResponseCode.FAIL, "No header data found.");
        PAYLOAD_DATA_MISSING = new MslError(6011, MslConstants$ResponseCode.FAIL, "No payload data found in non-EOM payload chunk.");
        PAYLOAD_DATA_CORRUPT = new MslError(6012, MslConstants$ResponseCode.FAIL, "Corrupt payload data found in non-EOM payload chunk.");
        UNIDENTIFIED_COMPRESSION = new MslError(6013, MslConstants$ResponseCode.FAIL, "Unidentified compression algorithm.");
        MESSAGE_EXPIRED = new MslError(6014, MslConstants$ResponseCode.EXPIRED, "Message expired and not renewable. Rejected.");
        MESSAGE_ID_OUT_OF_RANGE = new MslError(6015, MslConstants$ResponseCode.FAIL, "Message ID is is out of range.");
        INTERNAL_CODE_NEGATIVE = new MslError(6016, MslConstants$ResponseCode.FAIL, "Error header internal code is negative.");
        UNEXPECTED_RESPONSE_MESSAGE_ID = new MslError(6017, MslConstants$ResponseCode.FAIL, "Unexpected response message ID. Possible replay.");
        RESPONSE_REQUIRES_ENCRYPTION = new MslError(6018, MslConstants$ResponseCode.KEYX_REQUIRED, "Message response requires encryption.");
        PAYLOAD_SEQUENCE_NUMBER_OUT_OF_RANGE = new MslError(6019, MslConstants$ResponseCode.FAIL, "Payload chunk sequence number is out of range.");
        PAYLOAD_MESSAGE_ID_OUT_OF_RANGE = new MslError(6020, MslConstants$ResponseCode.FAIL, "Payload chunk message ID is out of range.");
        MESSAGE_REPLAYED = new MslError(6021, MslConstants$ResponseCode.REPLAYED, "Non-replayable message replayed.");
        INCOMPLETE_NONREPLAYABLE_MESSAGE = new MslError(6022, MslConstants$ResponseCode.FAIL, "Non-replayable message sent without a master token.");
        HEADER_SIGNATURE_INVALID = new MslError(6023, MslConstants$ResponseCode.FAIL, "Invalid Header signature.");
        HEADER_DATA_INVALID = new MslError(6024, MslConstants$ResponseCode.FAIL, "Invalid header data.");
        PAYLOAD_INVALID = new MslError(6025, MslConstants$ResponseCode.FAIL, "Invalid payload.");
        PAYLOAD_SIGNATURE_INVALID = new MslError(6026, MslConstants$ResponseCode.FAIL, "Invalid payload signature.");
        RESPONSE_REQUIRES_MASTERTOKEN = new MslError(6027, MslConstants$ResponseCode.KEYX_REQUIRED, "Message response requires a master token.");
        RESPONSE_REQUIRES_USERIDTOKEN = new MslError(6028, MslConstants$ResponseCode.USER_REAUTH, "Message response requires a user ID token.");
        REQUEST_REQUIRES_USERAUTHDATA = new MslError(6029, MslConstants$ResponseCode.FAIL, "User-associated message requires user authentication data.");
        UNEXPECTED_MESSAGE_SENDER = new MslError(6030, MslConstants$ResponseCode.FAIL, "Message sender is equal to the local entity or not the master token entity.");
        NONREPLAYABLE_MESSAGE_REQUIRES_MASTERTOKEN = new MslError(6031, MslConstants$ResponseCode.FAIL, "Non-replayable message requires a master token.");
        NONREPLAYABLE_ID_OUT_OF_RANGE = new MslError(6032, MslConstants$ResponseCode.FAIL, "Non-replayable message non-replayable ID is out of range.");
        MESSAGE_SERVICETOKEN_MISMATCH = new MslError(6033, MslConstants$ResponseCode.FAIL, "Service token master token or user ID token serial number does not match the message token serial numbers.");
        MESSAGE_PEER_SERVICETOKEN_MISMATCH = new MslError(6034, MslConstants$ResponseCode.FAIL, "Peer service token master token or user ID token serial number does not match the message peer token serial numbers.");
        RESPONSE_REQUIRES_INTEGRITY_PROTECTION = new MslError(6035, MslConstants$ResponseCode.KEYX_REQUIRED, "Message response requires integrity protection.");
        HANDSHAKE_DATA_MISSING = new MslError(6036, MslConstants$ResponseCode.FAIL, "Handshake message is not renewable or does not contain key request data.");
        MESSAGE_RECIPIENT_MISMATCH = new MslError(6037, MslConstants$ResponseCode.FAIL, "Message recipient does not match local identity.");
        MESSAGE_ENTITYDATABASED_VERIFICATION_FAILED = new MslError(6038, MslConstants$ResponseCode.ENTITYDATA_REAUTH, "Message header entity-based signature verification failed.");
        MESSAGE_MASTERTOKENBASED_VERIFICATION_FAILED = new MslError(6039, MslConstants$ResponseCode.ENTITY_REAUTH, "Message header master token-based signature verification failed.");
        MESSAGE_REPLAYED_UNRECOVERABLE = new MslError(6040, MslConstants$ResponseCode.ENTITY_REAUTH, "Non-replayable message replayed with a sequence number that is too far out of sync to recover.");
        UNIDENTIFIED_KEYX_SCHEME = new MslError(7000, MslConstants$ResponseCode.FAIL, "Unable to identify key exchange scheme.");
        KEYX_FACTORY_NOT_FOUND = new MslError(7001, MslConstants$ResponseCode.FAIL, "No factory registered for key exchange scheme.");
        KEYX_REQUEST_NOT_FOUND = new MslError(7002, MslConstants$ResponseCode.FAIL, "No key request found matching header key response data.");
        UNIDENTIFIED_KEYX_KEY_ID = new MslError(7003, MslConstants$ResponseCode.FAIL, "Unable to identify key exchange key ID.");
        UNSUPPORTED_KEYX_KEY_ID = new MslError(7004, MslConstants$ResponseCode.FAIL, "Unsupported key exchange key ID.");
        UNIDENTIFIED_KEYX_MECHANISM = new MslError(7005, MslConstants$ResponseCode.FAIL, "Unable to identify key exchange mechanism.");
        UNSUPPORTED_KEYX_MECHANISM = new MslError(7006, MslConstants$ResponseCode.FAIL, "Unsupported key exchange mechanism.");
        KEYX_RESPONSE_REQUEST_MISMATCH = new MslError(7007, MslConstants$ResponseCode.FAIL, "Key exchange response does not match request.");
        KEYX_PRIVATE_KEY_MISSING = new MslError(7008, MslConstants$ResponseCode.FAIL, "Key exchange private key missing.");
        UNKNOWN_KEYX_PARAMETERS_ID = new MslError(7009, MslConstants$ResponseCode.FAIL, "Key exchange parameters ID unknown or invalid.");
        KEYX_MASTER_TOKEN_MISSING = new MslError(7010, MslConstants$ResponseCode.FAIL, "Master token required for key exchange is missing.");
        KEYX_INVALID_PUBLIC_KEY = new MslError(7011, MslConstants$ResponseCode.FAIL, "Key exchange public key is invalid.");
        KEYX_PUBLIC_KEY_MISSING = new MslError(7012, MslConstants$ResponseCode.FAIL, "Key exchange public key missing.");
        KEYX_WRAPPING_KEY_MISSING = new MslError(7013, MslConstants$ResponseCode.FAIL, "Key exchange wrapping key missing.");
        KEYX_WRAPPING_KEY_ID_MISSING = new MslError(7014, MslConstants$ResponseCode.FAIL, "Key exchange wrapping key ID missing.");
        KEYX_INVALID_WRAPPING_KEY = new MslError(7015, MslConstants$ResponseCode.FAIL, "Key exchange wrapping key is invalid.");
        KEYX_INCORRECT_DATA = new MslError(7016, MslConstants$ResponseCode.FAIL, "Entity used incorrect key exchange data type.");
        KEYX_INCORRECT_MECHANISM = new MslError(7017, MslConstants$ResponseCode.FAIL, "Entity used incorrect key exchange mecahnism.");
        KEYX_DERIVATION_KEY_MISSING = new MslError(7018, MslConstants$ResponseCode.FAIL, "Key exchange derivation key missing.");
        KEYX_INVALID_ENCRYPTION_KEY = new MslError(7019, MslConstants$ResponseCode.FAIL, "Key exchange encryption key is invalid.");
        KEYX_INVALID_HMAC_KEY = new MslError(7020, MslConstants$ResponseCode.FAIL, "Key exchange HMAC key is invalid.");
        KEYX_INVALID_WRAPDATA = new MslError(7021, MslConstants$ResponseCode.FAIL, "Key exchange wrap data is invalid.");
        UNSUPPORTED_KEYX_SCHEME = new MslError(7022, MslConstants$ResponseCode.FAIL, "Unsupported key exchange scheme.");
        INTERNAL_EXCEPTION = new MslError(9000, MslConstants$ResponseCode.TRANSIENT_FAILURE, "Internal exception.");
        MSL_COMMS_FAILURE = new MslError(9001, MslConstants$ResponseCode.FAIL, "Error communicating with MSL entity.");
        NONE = new MslError(9999, MslConstants$ResponseCode.FAIL, "Special unit test error.");
    }
    
    protected MslError(final int n, final MslConstants$ResponseCode mslConstants$ResponseCode, final String msg) {
        synchronized (MslError.internalCodes) {
            if (MslError.internalCodes.contains(n)) {
                throw new MslInternalException("Duplicate MSL error definition for error code " + n + ".");
            }
        }
        MslError.internalCodes.add(n);
        // monitorexit(set)
        this.internalCode = 100000 + n;
        final MslConstants$ResponseCode responseCode;
        this.responseCode = responseCode;
        this.msg = msg;
    }
    
    @Override
    public boolean equals(final Object o) {
        if (o != this) {
            if (!(o instanceof MslError)) {
                return false;
            }
            final MslError mslError = (MslError)o;
            if (this.internalCode != mslError.internalCode || this.responseCode != mslError.responseCode) {
                return false;
            }
        }
        return true;
    }
    
    public int getInternalCode() {
        return this.internalCode;
    }
    
    public String getMessage() {
        return this.msg;
    }
    
    public MslConstants$ResponseCode getResponseCode() {
        return this.responseCode;
    }
    
    @Override
    public int hashCode() {
        return Integer.valueOf(this.internalCode).hashCode() ^ this.responseCode.hashCode();
    }
}
